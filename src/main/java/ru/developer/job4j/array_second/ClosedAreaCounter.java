package ru.developer.job4j.array_second;

/**
 * Вам предоставляется двумерный массив целых чисел, представляющий карту, где:
 *     1 — это часть стены,
 *     0 — это пустое пространство.
 * Замкнутая область — это участок пустого пространства, который окружен стенами (1) со всех сторон. Вам необходимо найти количество замкнутых областей на карте.
 * Требования:
 *     Написать класс ClosedAreaCounter с методом countClosedAreas, который принимает двумерный массив и возвращает количество замкнутых областей.
 *     Замкнутая область — это группа клеток с 0, которые окружены 1 по горизонтали, вертикали или диагонали и не соприкасаются с границей карты (клетками на краю массива).
 *     Метод должен корректно работать с картами различного размера и сложности, включая карты без замкнутых областей.
 * Пример:
 * Для карты:
 * int[][] map = {
 *     {1, 1, 1, 1, 1},
 *     {1, 0, 0, 1, 1},
 *     {1, 0, 1, 1, 1},
 *     {1, 1, 1, 0, 0},
 *     {1, 1, 1, 1, 1}
 * };
 * Ваш метод должен вернуть 1, так как на карте есть одна замкнутая область.
 * Условия:
 *     Размер карты ограничен до 50x50 клеток.
 *     Область считается замкнутой, если она не соприкасается с границей карты.
 *     Если на карте нет замкнутых областей, метод должен вернуть 0.
 */
public class ClosedAreaCounter {

    public int countClosedAreas(int[][] map) {
        int count = 0;
        for (int i = 0; i < map.length; i++) {
            for (int j = 0; j < map[i].length; j++) {
                if (map[i][j] == 0) {
                    if (isClosedArea(map, i, j)) {
                        count++;
                    }
                }
            }
        }
        return count;
    }

    // Вспомогательный метод для проверки замкнутой области
    private boolean isClosedArea(int[][] map, int row, int col) {
        if (row < 0 || row >= map.length || col < 0 || col >= map[0].length) {
            return false;
        }

        // выход с рекурсии при появлении стены
        if (map[row][col] == 1) {
            return true;
        }
        // помечаем пройденное пространство
        map[row][col] = 1;

        boolean up = isClosedArea(map, row - 1, col);
        boolean down = isClosedArea(map, row + 1, col);
        boolean left = isClosedArea(map, row, col - 1);
        boolean right = isClosedArea(map, row, col + 1);

        return up && down && left && right;
    }
}